"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const index_1 = require("./index");
const mocks_1 = require("./mocks");
describe('F1TelemetryClient', () => {
    describe('constructor', () => {
        describe('default settings', () => {
            describe('when no parameters are passed', () => {
                let f1TelemetryClient;
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                });
                it('should set default port, forwardAddresses and bigintEnabled to default values', () => {
                    expect(f1TelemetryClient.port).toBe(index_1.DEFAULT_PORT);
                    expect(f1TelemetryClient.forwardAddresses).toBe(index_1.FORWARD_ADDRESSES);
                    expect(f1TelemetryClient.bigintEnabled).toBe(index_1.BIGINT_ENABLED);
                });
                it('should set up client as udp4 client', () => {
                    expect(f1TelemetryClient.socket).toBeDefined();
                    // tslint:disable-next-line:no-any
                    expect(f1TelemetryClient.socket.type).toBe('udp4');
                });
            });
        });
        describe('port attribute', () => {
            describe('when a custom port is passed through parameters', () => {
                let f1TelemetryClient;
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ port: 20778 });
                });
                it('should set custom port', () => {
                    expect(f1TelemetryClient.port).toBe(20778);
                });
                it('should set forwardAddresses, forward port and bigintEnabled to default values', () => {
                    expect(f1TelemetryClient.forwardAddresses).toBe(index_1.FORWARD_ADDRESSES);
                    expect(f1TelemetryClient.bigintEnabled).toBe(index_1.BIGINT_ENABLED);
                });
                it('should set up client as udp4 client', () => {
                    expect(f1TelemetryClient.socket).toBeDefined();
                    // tslint:disable-next-line:no-any
                    expect(f1TelemetryClient.socket.type).toBe('udp4');
                });
            });
        });
        describe('parser enabled attribute', () => {
            describe('when parser enabled is passed through parameters', () => {
                let f1TelemetryClient;
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({
                        forwardAddresses: [{ port: 4477 }],
                    });
                });
                it('should set parser enabled', () => {
                    expect(f1TelemetryClient.forwardAddresses).toStrictEqual([
                        { port: 4477 },
                    ]);
                });
                it('should set port, forward port and bigintEnabled to default values', () => {
                    expect(f1TelemetryClient.port).toBe(index_1.DEFAULT_PORT);
                    expect(f1TelemetryClient.bigintEnabled).toBe(index_1.BIGINT_ENABLED);
                });
                it('should set up client as udp4 client', () => {
                    expect(f1TelemetryClient.socket).toBeDefined();
                    // tslint:disable-next-line:no-any
                    expect(f1TelemetryClient.socket.type).toBe('udp4');
                });
            });
        });
        describe('bigintEnabled attribute', () => {
            describe('when bigint enabled is passed through parameters', () => {
                let f1TelemetryClient;
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                });
                it('should set bigint enabled', () => {
                    expect(f1TelemetryClient.bigintEnabled).toBe(false);
                });
                it('should set forwardAddresses, forward port and port to default values', () => {
                    expect(f1TelemetryClient.forwardAddresses).toBe(index_1.FORWARD_ADDRESSES);
                    expect(f1TelemetryClient.port).toBe(index_1.DEFAULT_PORT);
                });
                it('should set up client as udp4 client', () => {
                    expect(f1TelemetryClient.socket).toBeDefined();
                    // tslint:disable-next-line:no-any
                    expect(f1TelemetryClient.socket.type).toBe('udp4');
                });
            });
        });
    });
    describe('2018 format', () => {
        describe('parsePacketHeader', () => {
            // tslint:disable-next-line:no-any
            let parsedPacketHeader;
            beforeAll(() => {
                const buffer = Buffer.from(mocks_1.PACKET_HEADER_BUFFER_2018);
                parsedPacketHeader = index_1.F1TelemetryClient.parsePacketHeader(buffer, true);
            });
            it('should parse buffer and return parsed packet header', () => {
                expect(parsedPacketHeader).toEqual(mocks_1.PACKET_HEADER_PARSED_2018);
            });
        });
        describe('handleMessage', () => {
            let f1TelemetryClient;
            describe('PacketSessionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_SESSION_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketSessionData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('session', mocks_1.PACKET_SESSION_DATA_PARSED_2018);
                });
            });
            describe('PacketParticipantsData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_PARTICIPANTS_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketParticipantsData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('participants', mocks_1.PACKET_PARTICIPANTS_DATA_PARSED_2018);
                });
            });
            describe('PacketCarTelemetryData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_TELEMETRY_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarTelemetryData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carTelemetry', mocks_1.PACKET_CAR_TELEMETRY_DATA_PARSED_2018);
                });
            });
            describe('PacketCarStatusData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_STATUS_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarStatusData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carStatus', mocks_1.PACKET_CAR_STATUS_DATA_PARSED_2018);
                });
            });
            describe('PacketLapData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_LAP_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketLapData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('lapData', mocks_1.PACKET_LAP_DATA_PARSED_2018);
                });
            });
            describe('PacketMotionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_MOTION_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketMotionData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('motion', mocks_1.PACKET_MOTION_DATA_PARSED_2018);
                });
            });
            describe('PacketCarSetupData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_SETUP_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarSetupData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carSetups', mocks_1.PACKET_CAR_SETUP_DATA_PARSED_2018);
                });
            });
            describe('PacketEventData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_EVENT_DATA_BUFFER_2018);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketEventData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('event', mocks_1.PACKET_EVENT_DATA_PARSED_2018);
                });
            });
        });
    });
    describe('2019 format', () => {
        describe('parsePacketHeader', () => {
            // tslint:disable-next-line:no-any
            let parsedPacketHeader;
            beforeAll(() => {
                const buffer = Buffer.from(mocks_1.PACKET_HEADER_BUFFER_2019);
                parsedPacketHeader = index_1.F1TelemetryClient.parsePacketHeader(buffer, true);
            });
            it('should parse buffer and return parsed packet header', () => {
                expect(parsedPacketHeader).toEqual(mocks_1.PACKET_HEADER_PARSED_2019);
            });
        });
        describe('handleMessage', () => {
            let f1TelemetryClient;
            describe('PacketSessionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_SESSION_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketSessionData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('session', mocks_1.PACKET_SESSION_DATA_PARSED_2019);
                });
            });
            describe('PacketParticipantsData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_PARTICIPANTS_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketParticipantsData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('participants', mocks_1.PACKET_PARTICIPANTS_DATA_PARSED_2019);
                });
            });
            describe('PacketCarTelemetryData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_TELEMETRY_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarTelemetryData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carTelemetry', mocks_1.PACKET_CAR_TELEMETRY_DATA_PARSED_2019);
                });
            });
            describe('PacketCarStatusData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_STATUS_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarStatusData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carStatus', mocks_1.PACKET_CAR_STATUS_DATA_PARSED_2019);
                });
            });
            describe('PacketLapData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_LAP_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketLapData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('lapData', mocks_1.PACKET_LAP_DATA_PARSED_2019);
                });
            });
            describe('PacketMotionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_MOTION_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketMotionData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('motion', mocks_1.PACKET_MOTION_DATA_PARSED_2019);
                });
            });
            describe('PacketCarSetupData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_SETUP_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarSetupData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carSetups', mocks_1.PACKET_CAR_SETUP_DATA_PARSED_2019);
                });
            });
            describe('PacketEventData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_EVENT_DATA_BUFFER_2019);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketEventData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('event', mocks_1.PACKET_EVENT_DATA_PARSED_2019);
                });
            });
        });
    });
    describe('2020 format', () => {
        describe('parsePacketHeader', () => {
            // tslint:disable-next-line:no-any
            let parsedPacketHeader;
            beforeAll(() => {
                const buffer = Buffer.from(mocks_1.PACKET_HEADER_BUFFER_2020);
                parsedPacketHeader = index_1.F1TelemetryClient.parsePacketHeader(buffer, true);
            });
            it('should parse buffer and return parsed packet header', () => {
                expect(parsedPacketHeader).toEqual(mocks_1.PACKET_HEADER_PARSED_2020);
            });
        });
        describe('handleMessage', () => {
            let f1TelemetryClient;
            describe('PacketSessionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_SESSION_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketSessionData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('session', mocks_1.PACKET_SESSION_DATA_PARSED_2020);
                });
            });
            describe('PacketParticipantsData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_PARTICIPANTS_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketParticipantsData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('participants', mocks_1.PACKET_PARTICIPANTS_DATA_PARSED_2020);
                });
            });
            describe('PacketCarTelemetryData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_TELEMETRY_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarTelemetryData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carTelemetry', mocks_1.PACKET_CAR_TELEMETRY_DATA_PARSED_2020);
                });
            });
            describe('PacketCarStatusData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_STATUS_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarStatusData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carStatus', mocks_1.PACKET_CAR_STATUS_DATA_PARSED_2020);
                });
            });
            describe('PacketLapData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_LAP_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketLapData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('lapData', mocks_1.PACKET_LAP_DATA_PARSED_2020);
                });
            });
            describe('PacketMotionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_MOTION_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketMotionData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('motion', mocks_1.PACKET_MOTION_DATA_PARSED_2020);
                });
            });
            describe('PacketCarSetupData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_SETUP_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarSetupData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carSetups', mocks_1.PACKET_CAR_SETUP_DATA_PARSED_2020);
                });
            });
            describe('PacketEventData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_EVENT_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketEventData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('event', mocks_1.PACKET_EVENT_DATA_PARSED_2020);
                });
            });
            describe('PacketLobbyInfoData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_LOBBY_INFO_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketLobbyInfoData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('lobbyInfo', mocks_1.PACKET_LOBBY_INFO_DATA_PARSED_2020);
                });
            });
            describe('PacketFinalClassificationData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient();
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_FINAL_CLASSIFICATION_DATA_BUFFER_2020);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketFinalClassificationData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('finalClassification', mocks_1.PACKET_FINAL_CLASSIFICATION_DATA_PARSED_2020);
                });
            });
        });
    });
    describe('2021 format', () => {
        describe('parsePacketHeader', () => {
            // tslint:disable-next-line:no-any
            let parsedPacketHeader;
            beforeAll(() => {
                const buffer = Buffer.from(mocks_1.PACKET_HEADER_BUFFER_2021);
                parsedPacketHeader = index_1.F1TelemetryClient.parsePacketHeader(buffer, false);
            });
            it('should parse buffer and return parsed packet header', () => {
                expect(parsedPacketHeader).toEqual(mocks_1.PACKET_HEADER_PARSED_2021);
            });
        });
        describe('handleMessage', () => {
            let f1TelemetryClient;
            describe('PacketSessionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_SESSION_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketSessionData buffer', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('session', mocks_1.PACKET_SESSION_DATA_PARSED_2021);
                });
            });
            describe('PacketParticipantsData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_PARTICIPANTS_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketParticipantsData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('participants', mocks_1.PACKET_PARTICIPANTS_DATA_PARSED_2021);
                });
            });
            describe('PacketCarTelemetryData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_TELEMETRY_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarTelemetryData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carTelemetry', mocks_1.PACKET_CAR_TELEMETRY_DATA_PARSED_2021);
                });
            });
            describe('PacketCarStatusData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_STATUS_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarStatusData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carStatus', mocks_1.PACKET_CAR_STATUS_DATA_PARSED_2021);
                });
            });
            describe('PacketLapData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_LAP_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketLapData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('lapData', mocks_1.PACKET_LAP_DATA_PARSED_2021);
                });
            });
            describe('PacketMotionData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_MOTION_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketMotionData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('motion', mocks_1.PACKET_MOTION_DATA_PARSED_2021);
                });
            });
            describe('PacketCarSetupData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_CAR_SETUP_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketCarSetupData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('carSetups', mocks_1.PACKET_CAR_SETUP_DATA_PARSED_2021);
                });
            });
            describe('PacketEventData', () => {
                beforeAll(() => {
                    f1TelemetryClient = new index_1.F1TelemetryClient({ bigintEnabled: false });
                    spyOn(events_1.EventEmitter.prototype, 'emit');
                    const buffer = Buffer.from(mocks_1.PACKET_EVENT_DATA_BUFFER_2021);
                    f1TelemetryClient.handleMessage(buffer);
                });
                it('should parse PacketEventData buffer and emit result', () => {
                    expect(events_1.EventEmitter.prototype.emit)
                        .toHaveBeenCalledWith('event', mocks_1.PACKET_EVENT_DATA_PARSED_2021);
                });
            });
            /*
      
            // TODO: CAR DAMAGE, LOBBY INFO, FINAL CLASSIFICATION, SESSION HISTORY
      
            describe('PacketLobbyInfoData', () => {
              beforeAll(() => {
                f1TelemetryClient = new F1TelemetryClient({bigintEnabled: false});
                spyOn(EventEmitter.prototype, 'emit');
                const buffer = Buffer.from(PACKET_LOBBY_INFO_DATA_BUFFER_2020);
                f1TelemetryClient.handleMessage(buffer);
              });
      
              it('should parse PacketLobbyInfoData buffer', () => {
                expect(EventEmitter.prototype.emit).toHaveBeenCalledWith(
                  'lobbyInfo',
                  PACKET_LOBBY_INFO_DATA_PARSED_2020
                );
              });
            });
      
            describe('PacketFinalClassificationData', () => {
              beforeAll(() => {
                f1TelemetryClient = new F1TelemetryClient({bigintEnabled: false});
                spyOn(EventEmitter.prototype, 'emit');
                const buffer = Buffer.from(
                  PACKET_FINAL_CLASSIFICATION_DATA_BUFFER_2021
                );
                f1TelemetryClient.handleMessage(buffer);
              });
      
              it('should parse PacketFinalClassificationData buffer', () => {
                expect(EventEmitter.prototype.emit).toHaveBeenCalledWith(
                  'finalClassification',
                  PACKET_FINAL_CLASSIFICATION_DATA_PARSED_2021
                );
              });
            });
      
            */
        });
    });
});
//# sourceMappingURL=index.spec.js.map